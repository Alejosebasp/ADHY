# Generated from C:/Users/Alejosebasp/Documents/UNAL/Lenguajes/ADHY/grammar\asm8080.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\24")
        buf.write("|\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\5\2(\n\2\3\2\6\2+\n\2\r\2\16\2,\3\3\5\3\60\n\3\3")
        buf.write("\3\3\3\5\3\64\n\3\3\3\5\3\67\n\3\3\4\3\4\5\4;\n\4\3\5")
        buf.write("\3\5\3\6\3\6\3\7\5\7B\n\7\3\7\3\7\3\7\3\b\3\b\3\t\3\t")
        buf.write("\5\tK\n\t\3\n\3\n\3\n\7\nP\n\n\f\n\16\nS\13\n\3\13\3\13")
        buf.write("\3\f\3\f\3\f\7\fZ\n\f\f\f\16\f]\13\f\3\r\3\r\3\r\7\rb")
        buf.write("\n\r\f\r\16\re\13\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\5\16p\n\16\3\17\3\17\3\20\3\20\3\21\3\21\3")
        buf.write("\22\3\22\3\23\3\23\3\23\2\2\24\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$\2\4\3\2\5\6\3\2\7\b\2z\2*\3\2\2\2")
        buf.write("\4/\3\2\2\2\68\3\2\2\2\b<\3\2\2\2\n>\3\2\2\2\fA\3\2\2")
        buf.write("\2\16F\3\2\2\2\20H\3\2\2\2\22L\3\2\2\2\24T\3\2\2\2\26")
        buf.write("V\3\2\2\2\30^\3\2\2\2\32o\3\2\2\2\34q\3\2\2\2\36s\3\2")
        buf.write("\2\2 u\3\2\2\2\"w\3\2\2\2$y\3\2\2\2&(\5\4\3\2\'&\3\2\2")
        buf.write("\2\'(\3\2\2\2()\3\2\2\2)+\7\23\2\2*\'\3\2\2\2+,\3\2\2")
        buf.write("\2,*\3\2\2\2,-\3\2\2\2-\3\3\2\2\2.\60\5\20\t\2/.\3\2\2")
        buf.write("\2/\60\3\2\2\2\60\63\3\2\2\2\61\64\5\6\4\2\62\64\5\f\7")
        buf.write("\2\63\61\3\2\2\2\63\62\3\2\2\2\63\64\3\2\2\2\64\66\3\2")
        buf.write("\2\2\65\67\5$\23\2\66\65\3\2\2\2\66\67\3\2\2\2\67\5\3")
        buf.write("\2\2\28:\5\b\5\29;\5\22\n\2:9\3\2\2\2:;\3\2\2\2;\7\3\2")
        buf.write("\2\2<=\7\16\2\2=\t\3\2\2\2>?\7\r\2\2?\13\3\2\2\2@B\5\32")
        buf.write("\16\2A@\3\2\2\2AB\3\2\2\2BC\3\2\2\2CD\5\16\b\2DE\5\22")
        buf.write("\n\2E\r\3\2\2\2FG\7\f\2\2G\17\3\2\2\2HJ\5\24\13\2IK\7")
        buf.write("\3\2\2JI\3\2\2\2JK\3\2\2\2K\21\3\2\2\2LQ\5\26\f\2MN\7")
        buf.write("\4\2\2NP\5\26\f\2OM\3\2\2\2PS\3\2\2\2QO\3\2\2\2QR\3\2")
        buf.write("\2\2R\23\3\2\2\2SQ\3\2\2\2TU\5 \21\2U\25\3\2\2\2V[\5\30")
        buf.write("\r\2WX\t\2\2\2XZ\5\30\r\2YW\3\2\2\2Z]\3\2\2\2[Y\3\2\2")
        buf.write("\2[\\\3\2\2\2\\\27\3\2\2\2][\3\2\2\2^c\5\32\16\2_`\t\3")
        buf.write("\2\2`b\5\32\16\2a_\3\2\2\2be\3\2\2\2ca\3\2\2\2cd\3\2\2")
        buf.write("\2d\31\3\2\2\2ec\3\2\2\2fp\5\"\22\2gp\5\n\6\2hp\5\34\17")
        buf.write("\2ip\5 \21\2jp\5\36\20\2kl\7\t\2\2lm\5\26\f\2mn\7\n\2")
        buf.write("\2np\3\2\2\2of\3\2\2\2og\3\2\2\2oh\3\2\2\2oi\3\2\2\2o")
        buf.write("j\3\2\2\2ok\3\2\2\2p\33\3\2\2\2qr\7\13\2\2r\35\3\2\2\2")
        buf.write("st\7\22\2\2t\37\3\2\2\2uv\7\17\2\2v!\3\2\2\2wx\7\20\2")
        buf.write("\2x#\3\2\2\2yz\7\21\2\2z%\3\2\2\2\16\',/\63\66:AJQ[co")
        return buf.getvalue()


class asm8080Parser ( Parser ):

    grammarFileName = "asm8080.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "':'", "','", "'+'", "'-'", "'*'", "'/'", 
                     "'('", "')'", "'$'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ASSEMBLER_DIRECTIVE", "REGISTER", 
                      "OPCODE", "NAME", "NUMBER", "COMMENT", "STRING", "EOL", 
                      "WS" ]

    RULE_prog = 0
    RULE_line = 1
    RULE_instruction = 2
    RULE_opcode = 3
    RULE_register_ = 4
    RULE_directive = 5
    RULE_assemblerdirective = 6
    RULE_lbl = 7
    RULE_expressionlist = 8
    RULE_label = 9
    RULE_expression = 10
    RULE_multiplyingExpression = 11
    RULE_argument = 12
    RULE_dollar = 13
    RULE_string = 14
    RULE_name = 15
    RULE_number = 16
    RULE_comment = 17

    ruleNames =  [ "prog", "line", "instruction", "opcode", "register_", 
                   "directive", "assemblerdirective", "lbl", "expressionlist", 
                   "label", "expression", "multiplyingExpression", "argument", 
                   "dollar", "string", "name", "number", "comment" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    ASSEMBLER_DIRECTIVE=10
    REGISTER=11
    OPCODE=12
    NAME=13
    NUMBER=14
    COMMENT=15
    STRING=16
    EOL=17
    WS=18

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(asm8080Parser.EOL)
            else:
                return self.getToken(asm8080Parser.EOL, i)

        def line(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(asm8080Parser.LineContext)
            else:
                return self.getTypedRuleContext(asm8080Parser.LineContext,i)


        def getRuleIndex(self):
            return asm8080Parser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = asm8080Parser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 37
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 36
                    self.line()


                self.state = 39
                self.match(asm8080Parser.EOL)
                self.state = 42 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << asm8080Parser.T__6) | (1 << asm8080Parser.T__8) | (1 << asm8080Parser.ASSEMBLER_DIRECTIVE) | (1 << asm8080Parser.REGISTER) | (1 << asm8080Parser.OPCODE) | (1 << asm8080Parser.NAME) | (1 << asm8080Parser.NUMBER) | (1 << asm8080Parser.COMMENT) | (1 << asm8080Parser.STRING) | (1 << asm8080Parser.EOL))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lbl(self):
            return self.getTypedRuleContext(asm8080Parser.LblContext,0)


        def instruction(self):
            return self.getTypedRuleContext(asm8080Parser.InstructionContext,0)


        def directive(self):
            return self.getTypedRuleContext(asm8080Parser.DirectiveContext,0)


        def comment(self):
            return self.getTypedRuleContext(asm8080Parser.CommentContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_line

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine" ):
                listener.enterLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine" ):
                listener.exitLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine" ):
                return visitor.visitLine(self)
            else:
                return visitor.visitChildren(self)




    def line(self):

        localctx = asm8080Parser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_line)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 44
                self.lbl()


            self.state = 49
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [asm8080Parser.OPCODE]:
                self.state = 47
                self.instruction()
                pass
            elif token in [asm8080Parser.T__6, asm8080Parser.T__8, asm8080Parser.ASSEMBLER_DIRECTIVE, asm8080Parser.REGISTER, asm8080Parser.NAME, asm8080Parser.NUMBER, asm8080Parser.STRING]:
                self.state = 48
                self.directive()
                pass
            elif token in [asm8080Parser.COMMENT, asm8080Parser.EOL]:
                pass
            else:
                pass
            self.state = 52
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==asm8080Parser.COMMENT:
                self.state = 51
                self.comment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opcode(self):
            return self.getTypedRuleContext(asm8080Parser.OpcodeContext,0)


        def expressionlist(self):
            return self.getTypedRuleContext(asm8080Parser.ExpressionlistContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstruction" ):
                return visitor.visitInstruction(self)
            else:
                return visitor.visitChildren(self)




    def instruction(self):

        localctx = asm8080Parser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_instruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.opcode()
            self.state = 56
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << asm8080Parser.T__6) | (1 << asm8080Parser.T__8) | (1 << asm8080Parser.REGISTER) | (1 << asm8080Parser.NAME) | (1 << asm8080Parser.NUMBER) | (1 << asm8080Parser.STRING))) != 0):
                self.state = 55
                self.expressionlist()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpcodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPCODE(self):
            return self.getToken(asm8080Parser.OPCODE, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_opcode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpcode" ):
                listener.enterOpcode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpcode" ):
                listener.exitOpcode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpcode" ):
                return visitor.visitOpcode(self)
            else:
                return visitor.visitChildren(self)




    def opcode(self):

        localctx = asm8080Parser.OpcodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_opcode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(asm8080Parser.OPCODE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Register_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGISTER(self):
            return self.getToken(asm8080Parser.REGISTER, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_register_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegister_" ):
                listener.enterRegister_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegister_" ):
                listener.exitRegister_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegister_" ):
                return visitor.visitRegister_(self)
            else:
                return visitor.visitChildren(self)




    def register_(self):

        localctx = asm8080Parser.Register_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_register_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self.match(asm8080Parser.REGISTER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assemblerdirective(self):
            return self.getTypedRuleContext(asm8080Parser.AssemblerdirectiveContext,0)


        def expressionlist(self):
            return self.getTypedRuleContext(asm8080Parser.ExpressionlistContext,0)


        def argument(self):
            return self.getTypedRuleContext(asm8080Parser.ArgumentContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirective" ):
                listener.enterDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirective" ):
                listener.exitDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirective" ):
                return visitor.visitDirective(self)
            else:
                return visitor.visitChildren(self)




    def directive(self):

        localctx = asm8080Parser.DirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_directive)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << asm8080Parser.T__6) | (1 << asm8080Parser.T__8) | (1 << asm8080Parser.REGISTER) | (1 << asm8080Parser.NAME) | (1 << asm8080Parser.NUMBER) | (1 << asm8080Parser.STRING))) != 0):
                self.state = 62
                self.argument()


            self.state = 65
            self.assemblerdirective()
            self.state = 66
            self.expressionlist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssemblerdirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSEMBLER_DIRECTIVE(self):
            return self.getToken(asm8080Parser.ASSEMBLER_DIRECTIVE, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_assemblerdirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssemblerdirective" ):
                listener.enterAssemblerdirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssemblerdirective" ):
                listener.exitAssemblerdirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssemblerdirective" ):
                return visitor.visitAssemblerdirective(self)
            else:
                return visitor.visitChildren(self)




    def assemblerdirective(self):

        localctx = asm8080Parser.AssemblerdirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_assemblerdirective)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(asm8080Parser.ASSEMBLER_DIRECTIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LblContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(asm8080Parser.LabelContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_lbl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLbl" ):
                listener.enterLbl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLbl" ):
                listener.exitLbl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLbl" ):
                return visitor.visitLbl(self)
            else:
                return visitor.visitChildren(self)




    def lbl(self):

        localctx = asm8080Parser.LblContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_lbl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.label()
            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==asm8080Parser.T__0:
                self.state = 71
                self.match(asm8080Parser.T__0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionlistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(asm8080Parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(asm8080Parser.ExpressionContext,i)


        def getRuleIndex(self):
            return asm8080Parser.RULE_expressionlist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionlist" ):
                listener.enterExpressionlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionlist" ):
                listener.exitExpressionlist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionlist" ):
                return visitor.visitExpressionlist(self)
            else:
                return visitor.visitChildren(self)




    def expressionlist(self):

        localctx = asm8080Parser.ExpressionlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_expressionlist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.expression()
            self.state = 79
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==asm8080Parser.T__1:
                self.state = 75
                self.match(asm8080Parser.T__1)
                self.state = 76
                self.expression()
                self.state = 81
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(asm8080Parser.NameContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = asm8080Parser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplyingExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(asm8080Parser.MultiplyingExpressionContext)
            else:
                return self.getTypedRuleContext(asm8080Parser.MultiplyingExpressionContext,i)


        def getRuleIndex(self):
            return asm8080Parser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = asm8080Parser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.multiplyingExpression()
            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==asm8080Parser.T__2 or _la==asm8080Parser.T__3:
                self.state = 85
                _la = self._input.LA(1)
                if not(_la==asm8080Parser.T__2 or _la==asm8080Parser.T__3):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 86
                self.multiplyingExpression()
                self.state = 91
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplyingExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(asm8080Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(asm8080Parser.ArgumentContext,i)


        def getRuleIndex(self):
            return asm8080Parser.RULE_multiplyingExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplyingExpression" ):
                listener.enterMultiplyingExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplyingExpression" ):
                listener.exitMultiplyingExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplyingExpression" ):
                return visitor.visitMultiplyingExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplyingExpression(self):

        localctx = asm8080Parser.MultiplyingExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_multiplyingExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.argument()
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==asm8080Parser.T__4 or _la==asm8080Parser.T__5:
                self.state = 93
                _la = self._input.LA(1)
                if not(_la==asm8080Parser.T__4 or _la==asm8080Parser.T__5):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 94
                self.argument()
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(asm8080Parser.NumberContext,0)


        def register_(self):
            return self.getTypedRuleContext(asm8080Parser.Register_Context,0)


        def dollar(self):
            return self.getTypedRuleContext(asm8080Parser.DollarContext,0)


        def name(self):
            return self.getTypedRuleContext(asm8080Parser.NameContext,0)


        def string(self):
            return self.getTypedRuleContext(asm8080Parser.StringContext,0)


        def expression(self):
            return self.getTypedRuleContext(asm8080Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return asm8080Parser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = asm8080Parser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_argument)
        try:
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [asm8080Parser.NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.number()
                pass
            elif token in [asm8080Parser.REGISTER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.register_()
                pass
            elif token in [asm8080Parser.T__8]:
                self.enterOuterAlt(localctx, 3)
                self.state = 102
                self.dollar()
                pass
            elif token in [asm8080Parser.NAME]:
                self.enterOuterAlt(localctx, 4)
                self.state = 103
                self.name()
                pass
            elif token in [asm8080Parser.STRING]:
                self.enterOuterAlt(localctx, 5)
                self.state = 104
                self.string()
                pass
            elif token in [asm8080Parser.T__6]:
                self.enterOuterAlt(localctx, 6)
                self.state = 105
                self.match(asm8080Parser.T__6)
                self.state = 106
                self.expression()
                self.state = 107
                self.match(asm8080Parser.T__7)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DollarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return asm8080Parser.RULE_dollar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDollar" ):
                listener.enterDollar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDollar" ):
                listener.exitDollar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDollar" ):
                return visitor.visitDollar(self)
            else:
                return visitor.visitChildren(self)




    def dollar(self):

        localctx = asm8080Parser.DollarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_dollar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(asm8080Parser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(asm8080Parser.STRING, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_string

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString" ):
                listener.enterString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString" ):
                listener.exitString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString" ):
                return visitor.visitString(self)
            else:
                return visitor.visitChildren(self)




    def string(self):

        localctx = asm8080Parser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(asm8080Parser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(asm8080Parser.NAME, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = asm8080Parser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.match(asm8080Parser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(asm8080Parser.NUMBER, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = asm8080Parser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(asm8080Parser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(asm8080Parser.COMMENT, 0)

        def getRuleIndex(self):
            return asm8080Parser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComment" ):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = asm8080Parser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_comment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(asm8080Parser.COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





